{
    "created": 1701643121.0409622,
    "duration": 1.9655556678771973,
    "exitcode": 1,
    "root": "I:\\PYTHON\\catester",
    "environment": {},
    "summary": {
        "passed": 31,
        "failed": 12,
        "total": 43,
        "collected": 43
    },
    "collectors": [
        {
            "nodeid": "",
            "outcome": "passed",
            "result": [
                {
                    "nodeid": "catester/__init__.py",
                    "type": "Package"
                },
                {
                    "nodeid": "catester/tests/__init__.py",
                    "type": "Package"
                }
            ]
        },
        {
            "nodeid": "catester/__init__.py",
            "outcome": "passed",
            "result": []
        },
        {
            "nodeid": "catester/tests/test_class.py::Test",
            "outcome": "passed",
            "result": [
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases0]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases1]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases2]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases3]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases4]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases5]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases6]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases7]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases8]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases9]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases10]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases11]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases12]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases13]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases14]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases15]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases16]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases17]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases18]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases19]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases20]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases21]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases22]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases23]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases24]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases25]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases26]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases27]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases28]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases29]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases30]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases31]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases32]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases33]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases34]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases35]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases36]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases37]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases38]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases39]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases40]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases41]",
                    "type": "Function",
                    "lineno": 20
                },
                {
                    "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases42]",
                    "type": "Function",
                    "lineno": 20
                }
            ]
        },
        {
            "nodeid": "catester/tests/test_class.py",
            "outcome": "passed",
            "result": [
                {
                    "nodeid": "catester/tests/test_class.py::Test",
                    "type": "Class"
                }
            ]
        },
        {
            "nodeid": "catester/tests/__init__.py",
            "outcome": "passed",
            "result": [
                {
                    "nodeid": "catester/tests/test_class.py",
                    "type": "Module"
                }
            ]
        }
    ],
    "tests": [
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases0]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases0]",
                "testcases0",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.021163500001421198,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABD180>>\n"
            },
            "call": {
                "duration": 0.0004984000042895786,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006092000039643608,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABD180>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases1]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases1]",
                "testcases1",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.014239799995266367,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDC90>>\n"
            },
            "call": {
                "duration": 0.00037290000182110816,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006721000027027912,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDC90>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases2]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases2]",
                "testcases2",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.014147800000500865,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDB40>>\n"
            },
            "call": {
                "duration": 0.0005435999992187135,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0007100000002537854,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDB40>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases3]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases3]",
                "testcases3",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.018028000005870126,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDC00>>\n"
            },
            "call": {
                "duration": 0.0012455000032787211,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 40,
                    "message": "AssertionError: Variable var4 not found in student namespace\nassert 'var4' in {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...eError'>, 'BaseException': <class 'BaseException'>, ...}, 'va4': [1, 2], 'var1': 0.30000000000000004, 'var2': '1', ...}"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 40,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABDC00>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': 0.001, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...eError'>, 'BaseException': <class 'BaseException'>, ...}, 'va4': [1, 2], 'var1': 0.30000000000000004, 'var2': '1', ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute... <class 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': 0.3, 'var2': '1', 'var3': True, ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n>           assert name in namespace_student, f\"Variable {name} not found in student namespace\"\nE           AssertionError: Variable var4 not found in student namespace\nE           assert 'var4' in {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...eError'>, 'BaseException': <class 'BaseException'>, ...}, 'va4': [1, 2], 'var1': 0.30000000000000004, 'var2': '1', ...}\n\ntests\\test_class.py:40: AssertionError"
            },
            "teardown": {
                "duration": 0.001123600006394554,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDC00>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases4]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases4]",
                "testcases4",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.027742400001443457,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDE40>>\n"
            },
            "call": {
                "duration": 0.0006805999946664087,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 58,
                    "message": "AssertionError: Variable var5 has incorrect type\nassert <class 'list'> == <class 'tuple'>"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 58,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABDE40>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': 0.001, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...eError'>, 'BaseException': <class 'BaseException'>, ...}, 'va4': [1, 2], 'var1': 0.30000000000000004, 'var2': '1', ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute... <class 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': 0.3, 'var2': '1', 'var3': True, ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n>               assert type_student == type_reference, f\"Variable {name} has incorrect type\"\nE               AssertionError: Variable var5 has incorrect type\nE               assert <class 'list'> == <class 'tuple'>\n\ntests\\test_class.py:58: AssertionError"
            },
            "teardown": {
                "duration": 0.0013443999996525235,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDE40>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases5]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases5]",
                "testcases5",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.021949900001345668,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDED0>>\n"
            },
            "call": {
                "duration": 0.0008785000027273782,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 61,
                    "message": "AssertionError: Variable var6 has incorrect value\nassert {1, 2, 3} == {1, 2}\n  Extra items in the left set:\n  3\n  Use -v to get more diff"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 61,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABDED0>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': 0.001, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...eError'>, 'BaseException': <class 'BaseException'>, ...}, 'va4': [1, 2], 'var1': 0.30000000000000004, 'var2': '1', ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute... <class 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': 0.3, 'var2': '1', 'var3': True, ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n>                   assert val_student == val_reference, failure_msg\nE                   AssertionError: Variable var6 has incorrect value\nE                   assert {1, 2, 3} == {1, 2}\nE                     Extra items in the left set:\nE                     3\nE                     Use -v to get more diff\n\ntests\\test_class.py:61: AssertionError"
            },
            "teardown": {
                "duration": 0.0011911999972653575,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDED0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases6]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases6]",
                "testcases6",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.024629100000311155,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDD20>>\n"
            },
            "call": {
                "duration": 0.0003138999963994138,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005962999930488877,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDD20>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases7]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases7]",
                "testcases7",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.021972199996525887,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDDB0>>\n"
            },
            "call": {
                "duration": 0.0004639999970095232,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006638999984716065,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDDB0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases8]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases8]",
                "testcases8",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01405240000167396,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE080>>\n"
            },
            "call": {
                "duration": 0.00034079999750247225,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.000618500002019573,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE080>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases9]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases9]",
                "testcases9",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.013791400000627618,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE110>>\n"
            },
            "call": {
                "duration": 0.0005573000016738661,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0008084999935817905,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE110>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases10]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases10]",
                "testcases10",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.014360599998326506,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDFF0>>\n"
            },
            "call": {
                "duration": 0.0006674000032944605,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0008018000007723458,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDFF0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases11]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases11]",
                "testcases11",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.026276399999915157,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDF60>>\n"
            },
            "call": {
                "duration": 0.0006807000027038157,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006632000004174188,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABDF60>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases12]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases12]",
                "testcases12",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.02641829999629408,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE2C0>>\n"
            },
            "call": {
                "duration": 0.00046660000225529075,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0007295000032172538,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE2C0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases13]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases13]",
                "testcases13",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.02042589999473421,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE350>>\n"
            },
            "call": {
                "duration": 0.00037480000173673034,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.000887399997736793,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE350>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases14]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases14]",
                "testcases14",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.028764700000465382,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE1A0>>\n"
            },
            "call": {
                "duration": 0.0007259999983943999,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0012487999993027188,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE1A0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases15]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases15]",
                "testcases15",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.028693699998257216,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE0E0>>\n"
            },
            "call": {
                "duration": 0.0003699000008055009,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005907000013394281,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE0E0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases16]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases16]",
                "testcases16",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.0274104999989504,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE500>>\n"
            },
            "call": {
                "duration": 0.0003346999947098084,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0007327999992412515,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE500>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases17]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases17]",
                "testcases17",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.0194816000002902,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE620>>\n"
            },
            "call": {
                "duration": 0.0004788999940501526,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006202999938977882,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE620>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases18]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases18]",
                "testcases18",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.0182351000039489,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE6B0>>\n"
            },
            "call": {
                "duration": 0.00032279999868478626,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0008353000011993572,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE6B0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases19]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases19]",
                "testcases19",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.012847199999669101,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE4A0>>\n"
            },
            "call": {
                "duration": 0.00037900000461377203,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.000577899998461362,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE4A0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases20]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases20]",
                "testcases20",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.023397600001771934,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE5C0>>\n"
            },
            "call": {
                "duration": 0.0006024999966030009,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0008736000017961487,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE5C0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases21]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases21]",
                "testcases21",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01758710000285646,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE800>>\n"
            },
            "call": {
                "duration": 0.0004119000004720874,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005949999977019615,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE800>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases22]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases22]",
                "testcases22",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.014592799998354167,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE890>>\n"
            },
            "call": {
                "duration": 0.00043310000182827935,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005659000016748905,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE890>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases23]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases23]",
                "testcases23",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.013871600000129547,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE770>>\n"
            },
            "call": {
                "duration": 0.0004256999964127317,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005940999981248751,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE770>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases24]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases24]",
                "testcases24",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.015598800004227087,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE830>>\n"
            },
            "call": {
                "duration": 0.00042490000487305224,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005831999951624312,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE830>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases25]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases25]",
                "testcases25",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.023308000003453344,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEA40>>\n"
            },
            "call": {
                "duration": 0.0010291999933542684,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0012730999951600097,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEA40>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases26]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases26]",
                "testcases26",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01908269999694312,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEAD0>>\n"
            },
            "call": {
                "duration": 0.0006313000048976392,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 70,
                    "message": "AssertionError: Variable var_duration has incorrect value\nassert datetime.time...croseconds=10) == 5 days, 3:00:00\n  comparison failed\n  Obtained: 5 days, 3:00:00.000010\n  Expected: 5 days, 3:00:00"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 70,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABEAD0>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute....py'>, 'var_date': datetime.date(2023, 12, 3), 'var_datetime': datetime.datetime(2023, 12, 3, 23, 38, 40, 374337), ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute....py'>, 'var_date': datetime.date(2023, 12, 3), 'var_datetime': datetime.datetime(2023, 12, 3, 23, 38, 40, 374337), ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n>                   assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\nE                   AssertionError: Variable var_duration has incorrect value\nE                   assert datetime.time...croseconds=10) == 5 days, 3:00:00\nE                     comparison failed\nE                     Obtained: 5 days, 3:00:00.000010\nE                     Expected: 5 days, 3:00:00\n\ntests\\test_class.py:70: AssertionError"
            },
            "teardown": {
                "duration": 0.0006222999945748597,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEAD0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases27]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases27]",
                "testcases27",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.19726690000243252,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE9B0>>\n"
            },
            "call": {
                "duration": 0.00517779999790946,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0008406999986618757,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE9B0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases28]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases28]",
                "testcases28",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.016030999999202322,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABED10>>\n"
            },
            "call": {
                "duration": 0.004019100000732578,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 68,
                    "message": "AssertionError: Variable y has incorrect value"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 68,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABED10>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': 1e-05, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...,  9.29292929,  9.39393939,  9.49494949,\n        9.5959596 ,  9.6969697 ,  9.7979798 ,  9.8989899 , 10.        ]), ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...,  9.29292929,  9.39393939,  9.49494949,\n        9.5959596 ,  9.6969697 ,  9.7979798 ,  9.8989899 , 10.        ]), ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n>                       np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n\ntests\\test_class.py:66: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nargs = (<function assert_allclose.<locals>.compare at 0x000001F9A8AC84C0>, array([ 1.00000000e-04,  1.00938420e-01,  2.007488...76008,  0.13146699,  0.03083368, -0.07011396,\n       -0.17034683, -0.26884313, -0.36459873, -0.45663749, -0.54402111]))\nkwds = {'equal_nan': True, 'err_msg': '', 'header': 'Not equal to tolerance rtol=1e-08, atol=1e-05', 'verbose': True}\n\n    @wraps(func)\n    def inner(*args, **kwds):\n        with self._recreate_cm():\n>           return func(*args, **kwds)\nE           AssertionError: \nE           Not equal to tolerance rtol=1e-08, atol=1e-05\nE           \nE           Mismatched elements: 100 / 100 (100%)\nE           Max absolute difference: 0.0001\nE           Max relative difference: 0.00972825\nE            x: array([ 1.000000e-04,  1.009384e-01,  2.007489e-01,  2.985138e-01,\nE                   3.932366e-01,  4.839516e-01,  5.697341e-01,  6.497095e-01,\nE                   7.230626e-01,  7.890455e-01,  8.469856e-01,  8.962922e-01,...\nE            y: array([ 0.      ,  0.100838,  0.200649,  0.298414,  0.393137,  0.483852,\nE                   0.569634,  0.64961 ,  0.722963,  0.788945,  0.846886,  0.896192,\nE                   0.936363,  0.966988,  0.987755,  0.998452,  0.998971,  0.989306,...\n\nC:\\Users\\Michael\\AppData\\Local\\Programs\\Python\\Python310\\lib\\contextlib.py:79: AssertionError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <catester.tests.test_class.Test object at 0x000001F9A8ABED10>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': 1e-05, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...,  9.29292929,  9.39393939,  9.49494949,\n        9.5959596 ,  9.6969697 ,  9.7979798 ,  9.8989899 , 10.        ]), ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...,  9.29292929,  9.39393939,  9.49494949,\n        9.5959596 ,  9.6969697 ,  9.7979798 ,  9.8989899 , 10.        ]), ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n>                       raise AssertionError(failure_msg)\nE                       AssertionError: Variable y has incorrect value\n\ntests\\test_class.py:68: AssertionError"
            },
            "teardown": {
                "duration": 0.0007579000011901371,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABED10>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases29]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases29]",
                "testcases29",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.03814750000310596,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEBF0>>\n   Column1 Column2  Column3\n0        1       a     True\n1        2       B    False\n2        3       C     True\n<class 'pandas.core.frame.DataFrame'>\na    1\nb    2\nc    3\ndtype: int64\n<class 'pandas.core.series.Series'>\n   Column1 Column2  Column3\n0        1       A     True\n1        2       B    False\n2        3       C     True\n<class 'pandas.core.frame.DataFrame'>\na    1\nb    2\nc    3\ndtype: int64\n<class 'pandas.core.series.Series'>\n"
            },
            "call": {
                "duration": 0.00911140000243904,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 63,
                    "message": "AssertionError: Variable df has incorrect value\nassert False\n +  where False = <bound method NDFrame.equals of    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True>(   Column1 Column2  Column3\\n0        1       A     True\\n1        2       B    False\\n2        3       C     True)\n +    where <bound method NDFrame.equals of    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True> =    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True.equals"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 63,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABEBF0>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...:    Column1 Column2  Column3\n0        1       a     True\n1        2       B    False\n2        3       C     True, ...}\nnamespace_reference = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...:    Column1 Column2  Column3\n0        1       A     True\n1        2       B    False\n2        3       C     True, ...}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n>                   assert val_student.equals(val_reference), failure_msg\nE                   AssertionError: Variable df has incorrect value\nE                   assert False\nE                    +  where False = <bound method NDFrame.equals of    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True>(   Column1 Column2  Column3\\n0        1       A     True\\n1        2       B    False\\n2        3       C     True)\nE                    +    where <bound method NDFrame.equals of    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True> =    Column1 Column2  Column3\\n0        1       a     True\\n1        2       B    False\\n2        3       C     True.equals\n\ntests\\test_class.py:63: AssertionError"
            },
            "teardown": {
                "duration": 0.0007540999940829352,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEBF0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases30]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases30]",
                "testcases30",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.03243759999895701,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABECE0>>\n   Column1 Column2  Column3\n0        1       a     True\n1        2       B    False\n2        3       C     True\n<class 'pandas.core.frame.DataFrame'>\na    1\nb    2\nc    3\ndtype: int64\n<class 'pandas.core.series.Series'>\n   Column1 Column2  Column3\n0        1       A     True\n1        2       B    False\n2        3       C     True\n<class 'pandas.core.frame.DataFrame'>\na    1\nb    2\nc    3\ndtype: int64\n<class 'pandas.core.series.Series'>\n"
            },
            "call": {
                "duration": 0.00038050000148359686,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006093000047258101,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABECE0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases31]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases31]",
                "testcases31",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01767950000066776,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE9E0>>\n"
            },
            "call": {
                "duration": 0.00029429999995045364,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005830000009154901,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABE9E0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases32]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases32]",
                "testcases32",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.023186699996585958,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEE90>>\n"
            },
            "call": {
                "duration": 0.00046460000157821923,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0011594000025070272,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEE90>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases33]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases33]",
                "testcases33",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.028055700000550132,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEDA0>>\n"
            },
            "call": {
                "duration": 0.0005718999964301474,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0010527999984333292,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEDA0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases34]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases34]",
                "testcases34",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.016674799997417722,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEC50>>\n"
            },
            "call": {
                "duration": 0.0006024000031175092,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0006675999975414015,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEC50>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases35]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases35]",
                "testcases35",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01466630000504665,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF040>>\n"
            },
            "call": {
                "duration": 0.0003364000003784895,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0005949999977019615,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF040>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases36]",
            "lineno": 20,
            "outcome": "passed",
            "keywords": [
                "test_entrypoint[testcases36]",
                "testcases36",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.015115599999262486,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF0D0>>\n"
            },
            "call": {
                "duration": 0.0004245000018272549,
                "outcome": "passed"
            },
            "teardown": {
                "duration": 0.0007264000014401972,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF0D0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases37]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases37]",
                "testcases37",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01452640000206884,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEFB0>>\n"
            },
            "call": {
                "duration": 0.0005715000006603077,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 73,
                    "message": "AssertionError: Variable var2 does not match specified pattern\nassert '_x1234567890' == '-'\n  - -\n  + _x1234567890"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 73,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABEFB0>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n>               assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\nE               AssertionError: Variable var2 does not match specified pattern\nE               assert '_x1234567890' == '-'\nE                 - -\nE                 + _x1234567890\n\ntests\\test_class.py:73: AssertionError"
            },
            "teardown": {
                "duration": 0.0006752999979653396,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABEFB0>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases38]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases38]",
                "testcases38",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.018177399993874133,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF070>>\n"
            },
            "call": {
                "duration": 0.0004188999955658801,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 75,
                    "message": "AssertionError: Variable var2 does not contain specified pattern\nassert -1 > -1\n +  where -1 = <built-in method find of str object at 0x000001F9A8B30430>('-')\n +    where <built-in method find of str object at 0x000001F9A8B30430> = '_x1234567890'.find\n +      where '_x1234567890' = str('_x1234567890')"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 75,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABF070>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n                assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\n            elif qualification == \"contains\":\n>               assert str(val_student).find(pattern) > -1, f\"Variable {name} does not contain specified pattern\"\nE               AssertionError: Variable var2 does not contain specified pattern\nE               assert -1 > -1\nE                +  where -1 = <built-in method find of str object at 0x000001F9A8B30430>('-')\nE                +    where <built-in method find of str object at 0x000001F9A8B30430> = '_x1234567890'.find\nE                +      where '_x1234567890' = str('_x1234567890')\n\ntests\\test_class.py:75: AssertionError"
            },
            "teardown": {
                "duration": 0.0008036999934120104,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF070>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases39]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases39]",
                "testcases39",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.013259300001664087,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF280>>\n"
            },
            "call": {
                "duration": 0.000414699999964796,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 77,
                    "message": "AssertionError: Variable var2 does not start with specified pattern\nassert False\n +  where False = <built-in method startswith of str object at 0x000001F9A8B30430>('-')\n +    where <built-in method startswith of str object at 0x000001F9A8B30430> = '_x1234567890'.startswith\n +      where '_x1234567890' = str('_x1234567890')"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 77,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABF280>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n                assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\n            elif qualification == \"contains\":\n                assert str(val_student).find(pattern) > -1, f\"Variable {name} does not contain specified pattern\"\n            elif qualification == \"startsWith\":\n>               assert str(val_student).startswith(pattern), f\"Variable {name} does not start with specified pattern\"\nE               AssertionError: Variable var2 does not start with specified pattern\nE               assert False\nE                +  where False = <built-in method startswith of str object at 0x000001F9A8B30430>('-')\nE                +    where <built-in method startswith of str object at 0x000001F9A8B30430> = '_x1234567890'.startswith\nE                +      where '_x1234567890' = str('_x1234567890')\n\ntests\\test_class.py:77: AssertionError"
            },
            "teardown": {
                "duration": 0.0007112000021152198,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF280>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases40]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases40]",
                "testcases40",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.01609479999751784,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF310>>\n"
            },
            "call": {
                "duration": 0.000396099996578414,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 79,
                    "message": "AssertionError: Variable var2 does not end with specified pattern\nassert False\n +  where False = <built-in method endswith of str object at 0x000001F9A8B30430>('-')\n +    where <built-in method endswith of str object at 0x000001F9A8B30430> = '_x1234567890'.endswith\n +      where '_x1234567890' = str('_x1234567890')"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 79,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABF310>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n                assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\n            elif qualification == \"contains\":\n                assert str(val_student).find(pattern) > -1, f\"Variable {name} does not contain specified pattern\"\n            elif qualification == \"startsWith\":\n                assert str(val_student).startswith(pattern), f\"Variable {name} does not start with specified pattern\"\n            elif qualification == \"endsWith\":\n>               assert str(val_student).endswith(pattern), f\"Variable {name} does not end with specified pattern\"\nE               AssertionError: Variable var2 does not end with specified pattern\nE               assert False\nE                +  where False = <built-in method endswith of str object at 0x000001F9A8B30430>('-')\nE                +    where <built-in method endswith of str object at 0x000001F9A8B30430> = '_x1234567890'.endswith\nE                +      where '_x1234567890' = str('_x1234567890')\n\ntests\\test_class.py:79: AssertionError"
            },
            "teardown": {
                "duration": 0.0006795000008423813,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF310>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases41]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases41]",
                "testcases41",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.027128399997309316,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF160>>\n"
            },
            "call": {
                "duration": 0.0006770999971195124,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 81,
                    "message": "AssertionError: Variable var2 does not contain specified pattern 1 times\nassert 0 == 1\n +  where 0 = <built-in method count of str object at 0x000001F9A8B30430>('-')\n +    where <built-in method count of str object at 0x000001F9A8B30430> = '_x1234567890'.count\n +      where '_x1234567890' = str('_x1234567890')"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 81,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABF160>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': 1, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n                assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\n            elif qualification == \"contains\":\n                assert str(val_student).find(pattern) > -1, f\"Variable {name} does not contain specified pattern\"\n            elif qualification == \"startsWith\":\n                assert str(val_student).startswith(pattern), f\"Variable {name} does not start with specified pattern\"\n            elif qualification == \"endsWith\":\n                assert str(val_student).endswith(pattern), f\"Variable {name} does not end with specified pattern\"\n            elif qualification == \"count\":\n>               assert str(val_student).count(pattern) == countRequirement, f\"Variable {name} does not contain specified pattern {countRequirement} times\"\nE               AssertionError: Variable var2 does not contain specified pattern 1 times\nE               assert 0 == 1\nE                +  where 0 = <built-in method count of str object at 0x000001F9A8B30430>('-')\nE                +    where <built-in method count of str object at 0x000001F9A8B30430> = '_x1234567890'.count\nE                +      where '_x1234567890' = str('_x1234567890')\n\ntests\\test_class.py:81: AssertionError"
            },
            "teardown": {
                "duration": 0.0013544999965233728,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF160>>\n"
            }
        },
        {
            "nodeid": "catester/tests/test_class.py::Test::test_entrypoint[testcases42]",
            "lineno": 20,
            "outcome": "failed",
            "keywords": [
                "test_entrypoint[testcases42]",
                "testcases42",
                "Test",
                "test_class.py",
                "catester/tests/__init__.py",
                "catester"
            ],
            "setup": {
                "duration": 0.021242399998300243,
                "outcome": "passed",
                "stdout": "setup_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF0A0>>\n"
            },
            "call": {
                "duration": 0.0005219999948167242,
                "outcome": "failed",
                "crash": {
                    "path": "I:\\PYTHON\\catester\\catester\\tests\\test_class.py",
                    "lineno": 85,
                    "message": "AssertionError: Variable var2 does not match specified regular expression\nassert None is not None"
                },
                "traceback": [
                    {
                        "path": "tests\\test_class.py",
                        "lineno": 85,
                        "message": "AssertionError"
                    }
                ],
                "longrepr": "self = <catester.tests.test_class.Test object at 0x000001F9A8ABF0A0>\ntestsuite = {'description': 'Checks variables', 'failureMessage': 'Some or all tests failed', 'name': 'Python Test suite', 'proper...tency': None, 'qualification': <QualificationEnum.verifyEqual: 'verifyEqual'>, 'referenceCommandList': None, ...}, ...}\ntestcase = ({'absoluteTolerance': None, 'allowedOccuranceRange': None, 'competency': None, 'description': None, ...}, {'absoluteTolerance': None, 'allowedOccuranceRange': None, 'countRequirement': None, 'description': None, ...})\nnamespace_student = {'__builtins__': {'ArithmeticError': <class 'ArithmeticError'>, 'AssertionError': <class 'AssertionError'>, 'Attribute...lass 'AttributeError'>, 'BaseException': <class 'BaseException'>, ...}, 'var1': '_x1234567890', 'var2': '_x1234567890'}\nnamespace_reference = {}\n\n    def test_entrypoint(self, testsuite, testcase, namespace_student, namespace_reference):\n        main, sub = testcase\n        ancestors = [sub, main, testsuite[\"properties\"]]\n    \n        relative_tolerance = self.get_inherited_property(\"relativeTolerance\", ancestors, None)\n        absolute_tolerance = self.get_inherited_property(\"absoluteTolerance\", ancestors, None)\n        allowed_occuranceRange = self.get_inherited_property(\"allowedOccuranceRange\", ancestors, None)\n        qualification = self.get_inherited_property(\"qualification\", ancestors, None)\n        testtype = self.get_inherited_property(\"type\", ancestors, None)\n    \n        if testtype == \"variable\":\n            name = sub[\"name\"]\n            value = sub[\"value\"]\n            evalString = sub[\"evalString\"]\n            pattern = sub[\"pattern\"]\n            countRequirement = sub[\"countRequirement\"]\n            options = sub[\"options\"]\n            verificationFunction = sub[\"verificationFunction\"]\n    \n            assert name in namespace_student, f\"Variable {name} not found in student namespace\"\n            val_student = namespace_student[name]\n    \n            if qualification == \"verifyEqual\":\n                if value is not None:\n                    val_reference = value\n                elif evalString is not None:\n                    try:\n                        val_reference = eval(evalString)\n                    except Exception as e:\n                        raise AssertionError(\"Evaluation of 'evalString' not possible\")\n                else:\n                    assert name in namespace_reference, f\"Variable {name} not found in reference namespace\"\n                    val_reference = namespace_reference[name]\n    \n                type_student = type(val_student)\n                type_reference = type(val_reference)\n                #strict type check vs isinstance(val_student, type_reference), hmmm?\n                assert type_student == type_reference, f\"Variable {name} has incorrect type\"\n                failure_msg = f\"Variable {name} has incorrect value\"\n                if isinstance(val_student, (str, set, frozenset)):\n                    assert val_student == val_reference, failure_msg\n                elif isinstance(val_student, (DataFrame, Series)):\n                    assert val_student.equals(val_reference), failure_msg\n                elif isinstance(val_student, np.ndarray):\n                    try:\n                        np.testing.assert_allclose(val_student, val_reference, rtol=relative_tolerance, atol=absolute_tolerance)\n                    except AssertionError as e:\n                        raise AssertionError(failure_msg)\n                else:\n                    assert val_student == approx(val_reference, rel=relative_tolerance, abs=absolute_tolerance), failure_msg\n            elif qualification == \"matches\":\n                #is that ok?\n                assert str(val_student) == pattern, f\"Variable {name} does not match specified pattern\"\n            elif qualification == \"contains\":\n                assert str(val_student).find(pattern) > -1, f\"Variable {name} does not contain specified pattern\"\n            elif qualification == \"startsWith\":\n                assert str(val_student).startswith(pattern), f\"Variable {name} does not start with specified pattern\"\n            elif qualification == \"endsWith\":\n                assert str(val_student).endswith(pattern), f\"Variable {name} does not end with specified pattern\"\n            elif qualification == \"count\":\n                assert str(val_student).count(pattern) == countRequirement, f\"Variable {name} does not contain specified pattern {countRequirement} times\"\n            elif qualification == \"regexp\":\n                re_pattern = re.compile(fr'{pattern}')\n                result = re.match(re_pattern, str(val_student))\n>               assert result is not None, f\"Variable {name} does not match specified regular expression\"\nE               AssertionError: Variable var2 does not match specified regular expression\nE               assert None is not None\n\ntests\\test_class.py:85: AssertionError"
            },
            "teardown": {
                "duration": 0.0007172999976319261,
                "outcome": "passed",
                "stdout": "teardown_method\n<bound method Test.test_entrypoint of <catester.tests.test_class.Test object at 0x000001F9A8ABF0A0>>\n"
            }
        }
    ]
}